/* Will not usually work on IE9 when simulating VML mode, because image-loaded callback doesn't fire in time.
   Too hard to fix the test right now. In practice this shouldn't ever matter unless you actually want to 
   test the selection state (as initially configured) before anything's been done.
*/
mapster_tests=function(n){var f=function(q){var p=this;p.cbData=false;p.cbThis=null;
this.onCallback=q;f.prototype.callback=function(r){p.cbData=r;p.cbThis=this;p.onCallback.call(p);
};};var a=function(q,p,s){var r=s.split(","),t=$();q.each(function(){for(var u=0;
u<r.length;u++){if($(this).is("["+p+"='"+r[u]+"']")){t=t.add(this);u=r.length;}}});
return t;};var h,j=new Test(n),d=false,g=null,c=function(p){d=p;g=this;},e=function(){d=null;
g=null;},k,m,l=function(){k=[];m=this;for(var p in arguments){if(arguments.hasOwnProperty(p)){k.push(arguments[p]);
}}},i={isSelectable:true,singleSelect:false,mapKey:"state",mapValue:"full",listKey:"name",listSelectedAttribute:"checked",sortList:"asc",onGetList:l,onClick:c,onMouseover:c,onMouseout:c,showToolTip:true,onShowToolTip:c,toolTipClose:["area-mouseout"],areas:[{key:"TX",selected:true},{key:"AK",isSelectable:false,selected:true},{key:"WA",staticState:true},{key:"OR",staticState:false},{key:"CA",toolTip:$('<div>Don\'t mess with Louisiana. Why ? <a href = "http://dontmesswithtexas.org/" target="_blank" > Click here </a> for more info. </div> ')}]};
j.addTest("Mapster Utility Function Tests",function(A){var x;var z=$.mapster.utils;
A.assertEq(function(){return z.isBool(true);},true,"isTrueFalse returns true=true");
A.assertEq(function(){return z.isBool(false);},true,"isBool returns false=true");
A.assertEq(function(){return z.isBool(null);},false,"isBool returns null=false");
A.assertEq(z.boolOrDefault(true),true,"boolOrDefault(true) returns true");A.assertEq(z.boolOrDefault(false),false,"boolOrDefault(false) returns false");
A.assertEq(z.boolOrDefault("something"),false,"boolOrDefault('something') (a truthy value) returns false");
A.assertEq(z.boolOrDefault(null),false,"boolOrDefault(null) (a falsy value)  returns false");
A.assertEq(z.boolOrDefault(true,"foo"),true,"boolOrDefault(true) with default value returns true");
A.assertEq(z.boolOrDefault(false,"foo"),false,"boolOrDefault(false) with default value returns false");
A.assertEq(z.boolOrDefault("something","foo"),"foo","boolOrDefault('something') (a falsy value) with default value returns default");
A.assertEq(z.boolOrDefault(undefined,"foo"),"foo","boolOrDefault(undefined) (a falsy value) with default value returns default");
var t={a:"a",b:"b"};var v={a:"a2",b:"b2",c:"c"};var q={a:[1,2],b:{a:"a2",b:"b2"}};
x=z.updateProps({},q);A.assertArrayEq([1,2],x.a,"Array copied as array");x=z.updateProps(t,v);
A.assertPropsEq(x,{a:"a2",b:"b2"},"Merge with extra properties - no add");A.assertPropsEq(t,{a:"a2",b:"b2"},"Test input object following merge matches output");
x=z.updateProps(v,t,v);A.assertPropsEq(x,{a:"a2",b:"b2",c:"c"},"Merge with extra properties - add");
v={a:"a3"};x=z.updateProps(t,v);t={a:"unchanged-a",b:"unchanged-b"};v={b:"b4"};var w={a:"a4"};
A.assertPropsEq(z.updateProps(t,v,w),{a:"a4",b:"b4"},"Merge with mutiple inputs");
var y={p1:"prop1",p2:"prop2"};v={p1:"newProp1",p3:"prop3",p4:"prop4"};A.assertPropsEq(z.updateProps({},y,v),{p1:"newProp1",p2:"prop2"},"Template works.");
var r={p1:"newProp1",p2:"prop2",p4:"prop4"};y.p3={subp1:"subprop1",subp2:"subprop2"};
y.p4=null;x={};r.p3=v.p3;z.updateProps(x,y,v);A.assertPropsEq(x,r,"Copying a sub-object - start");
delete v.p3;x.p3={existing:"bar"};r.p3=y.p3;r.p3.existing="bar";z.updateProps(x,y,v);
A.assertPropsEq(x,r,"Deep works");t={test:"test"};var p=[{name:"test1",value:"value1"},{name:"test2",value:"value2"},{name:"test3",value:t}];
var s=z.indexOfProp(p,"name","test2");A.assertEq(s,1,"arrayIndexOfProp returns correct value for string");
s=z.indexOfProp(p,"value",t);A.assertEq(s,2,"arrayIndexOfProp returns correct value for object & last element");
s=z.indexOfProp(p,"name","test1");A.assertEq(s,0,"arrayIndexOfProp returns correct value for first element");
s=z.indexOfProp(p,"foo","bar");A.assertEq(s,-1,"Missing property handled correctly");
s=z.indexOfProp(p,"name","bar");A.assertEq(s,-1,"Missing property value handled correctly");
});var b=function(A,q){var z=$.mapster.utils;var r=$("#test_elements *").length;h=$("img").mapster();
var s=(document.namespaces&&document.namespaces.g_vml_)?false:$("<canvas></canvas>")[0].getContext?true:false;
if(!s&&q){h.mapster("unbind");return;}h.mapster("unbind");var w=$.mapster.hasCanvas;
if(q){$.mapster.hasCanvas=false;}h=$("img").mapster(i);A.assertEq(h.mapster("test","typeof m !== 'undefined' && m.map_cache && m.map_cache.length"),1,"(ok to fail if obfuscated) Only imagemap bound images were obtained on generic create");
h=$("img,div").mapster({mapKey:"state"});A.assertEq(h.mapster("test","typeof m !== 'undefined' && m.map_cache && m.map_cache.length"),1,"(ok to fail if obfuscated) Only imagemap bound images were obtained on generic create with other elements");
h=$("#usa_image").mapster(i);var t=z.updateProps({},$.mapster.defaults,i);var x=h.mapster("get_options");
A.assertPropsEq(x,t,"Options retrieved match initial options");var v={isSelectable:false,areas:[{key:"MT",isDeselectable:false}]};
h.mapster("set_options",v);x=h.mapster("get_options");A.assertPropsEq(x,$.extend({},t,v),"Options retrieved match updated value");
A.assertEq(x.areas.length,6,"Area option was added");x=h.mapster("set_options",{isSelectable:true,areas:[{key:"MT",isDeselectable:true}]});
A.assertEq(!!h.mapster,true,"Plugin returns jQuery object");A.assertArrayEq(h,$("#usa_image"),"Plugin returns jquery same object as invocation");
var y=h.mapster("get");A.assertCsvElementsEq(y,"AK,TX","Initially selected items returned with 'get'");
y=h.mapster("get","TX");A.assertEq(y,true,"Initially selected single item returned true with 'get'");
y=h.mapster("get","ME");A.assertEq(y,false,"Initially deselected single item returned false with 'get'");
a($("area"),"state","AK,HI,LA").mapster("set",true);var p=h.mapster("get");A.assertCsvElementsEq(p,"HI,AK,LA,TX","Set using area works");
h.mapster("set",false,"LA,TX");A.assertCsvElementsEq("HI,AK",h.mapster("get"),"unset using keys works");
h.mapster("set",true,"ME,OH,TX");A.assertCsvElementsEq("HI,AK,ME,OH,TX",h.mapster("get"),"set using keys works");
a($("area"),"state","AK,MT").mapster("set");A.assertCsvElementsEq("HI,ME,OH,TX,MT",h.mapster("get"),"toggling keys works");
$('area[state="AZ"]').first().click();y=h.mapster("get","AZ");A.assertEq(true,y,"Click-selected area returned 'get'");
A.assertCsvElementsEq("HI,ME,OH,TX,MT,AZ",h.mapster("get"),"Complete list returned with 'get'");
$('area[state="OR"]').first().click();y=h.mapster("get","OR");A.assertEq(y,false,"Cannot select 'staticState=false' area with click");
y=h.mapster("get","WA");A.assertEq(y,false,"staticState=true area is considered not selected");
x=h.mapster("get_options","WA");A.assertEq(x.staticState,true,"get effective options returned correct static state for WA");
x=h.mapster("get_options","OR");A.assertEq(x.staticState,false,"get effective options returned correct static state for OR");
$('area[state="WA"]').first().click();y=h.mapster("get","WA");A.assertEq(y,false,"Cannot change selection state of 'staticState=true' area with click");
h.mapster("set",true,"OR");y=h.mapster("get","OR");A.assertEq(y,true,"Can select 'staticState=false' area with 'set'");
h.mapster("set",false,"WA");A.assertEq(h.mapster("get","WA"),false,"Can deselect staticState=true' area with 'set'");
h.mapster("rebind",{singleSelect:true});A.assertCsvElementsEq(h.mapster("get"),"OR,AZ,TX,MT,OH,ME,HI","Rebind with singleSelect preserved selections");
h.mapster("set",true,"MI");A.assertEq(h.mapster("get"),"MI","Single select worked.");
h.mapster("rebind",{isDeselectable:false});$('area[state="MI"]').first().click();
A.assertEq(h.mapster("get","MI"),true,"Cannot deselect single selected item with isDeselectable=false");
$('area[state="UT"]').first().click();A.assertEq(h.mapster("get"),"UT","New single state selected");
h.mapster("rebind",{singleSelect:false,isDeselectable:true,areas:[{key:"ME",isDeselectable:false}]});
$('area[state="UT"]').first().click();A.assertEq(h.mapster("get","UT"),false,"Was able to deselect item after removing singleSelect");
h.mapster("set",true,"CA,HI,ME");$('area[state="ME"]').first().click();A.assertEq(h.mapster("get","ME"),true,"Could not deselect one item marked as !isDeselectable");
$('area[state="CA"]').first().click();A.assertEq(h.mapster("get","CA"),false,"Could deselect other items ");
A.assertEq(h.mapster("highlight"),null,"nothing is highlighted");$('area[state="CA"]').first().mapster("highlight");
A.assertEq(h.mapster("highlight"),"CA","highlighted manually");h.mapster("highlight","LA");
A.assertEq(h.mapster("highlight"),"LA","highlighted manually using other technique");
h.mapster("highlight",false);A.assertEq(h.mapster("highlight"),null,"everything unhighlighted");
if(q){h.mapster("test","has_canvas=true");}else{if(s){A.assertEq($("canvas").length,2,"There are 2 canvases.");
h.mapster(i);A.assertEq($("canvas").length,2,"There are 2 canvases (recreate was clean)");
}}h.mapster("unbind");A.assertEq($("canvas").length,0,"No canvases remain after an unbind.");
A.assertEq($("#test_elements *").length,r,"# elements in DOM is the same.");if(q){$.mapster.hasCanvas=w;
}};if(!($.browser.msie&&$.browser.version<9)){j.addTest("Mapster Basic Tests - hasCanvas disabled",function(p){b(p,true);
});}j.addTest("Mapster Basic Tests",b);var o=function(w,q){var t=$.mapster.hasCanvas;
$.mapster.hasCanvas=false;$.mapster.initGraphics();var u={mapKey:"state",areas:[{key:"WA",selected:true}]};
var s=$("img").mapster(u);var p=$("#mapster_wrap_0");var v=p.find("var").children();
w.assertEq(2,v.length,"Correct # of shapes found on initial rendering");function r(){var y=[];
v.each(function(){var A=$(this).attr("path")||"";var z=A.indexOf(" l ");y.push(A&&z>=0?A.substring(0,z):"");
});return y;}var x=r();w.assertArrayElementsEq(["m 61,23","m 68,19"],x,"Correct area appears to have been rendered for initial selected");
s.mapster("set",false,"WA");v=p.find("var").children();w.assertEq(0,v.length,"Deselecting got rid of everything");
u={mapKey:"state",areas:[{key:"TX",staticState:true}]};s.mapster("unbind");s=$("img").mapster(u);
p=$("#mapster_wrap_0");v=p.find("var").children();x=r(v);w.assertEq(3,v.length,"Correct # of shapes found on initial rendering for TX staticState=true");
w.assertArrayElementsEq(["","m 332,426","m 259,256"],x,"Correct area appears to have been rendered for staticState");
u={mapKey:"state",selected:true};s.mapster("unbind");s=$("img").mapster(u);p=$("#mapster_wrap_0");
v=p.find("var").children();x=r(v);w.assertEq(116,v.length,"Correct # of shapes found on initial rendering for TX staticState=true");
delete u.selected;u.staticState=true;s.mapster("unbind");s=$("img").mapster(u);p=$("#mapster_wrap_0");
v=p.find("var").children();x=r(v);w.assertEq(116,v.length,"Correct # of shapes found on initial rendering for TX staticState=true");
$.mapster.hasCanvas=t;$.mapster.initGraphics();s.mapster("unbind");};j.addTest("Rendering Tests",o);
j.addTest("Keys",function(s){var r=$("img").mapster(i);var q=r.mapster("keys","TX");
s.assertEq("TX",q,"Got primary key for something with only one key");q=r.mapster("keys","ME");
s.assertEq("ME",q,"Got primary key for something with multiple keys");q=r.mapster("keys","new-england");
s.assertCsvElementsEq("ME,VT,NH,CT,RI,MA",q,"Got primary key for something with multiple keys");
q=r.mapster("keys","new-england",true);s.assertCsvElementsEq("ME,VT,NH,CT,RI,MA,new-england,really-cold",q,"Got primary key for something with multiple keys");
q=$('area[state="HI"]').mapster("keys");s.assertEq("HI",q,"Got primary key from an area");
var p=$('area[state="HI"],area[state*="new-england"]');q=p.mapster("keys");s.assertCsvElementsEq("HI,ME,VT,NH,CT,RI,MA",q,"Got primary key for something with multiple keys");
});j.addTest("Event/Tooltip Tests",function(r){var q=$("img").mapster(i);e();$('area[state="NV"]').first().mouseover();
r.assertIsTruthy(d,"Mouseover fired for Nevada");r.assertEq(d.selected,false,"Selected state returned correctly");
r.assertEq(d.key,"NV","Key returned correctly");e();$('area[state="AK"]').first().mouseover();
r.assertIsTruthy(d,"Mouseover fired for Alaska");r.assertEq(d.selected,true,"Selected state returned correctly");
r.assertEq(d.key,"AK","Key returned correctly");e();$('area[state="NV"]').first().mouseout();
r.assertIsTruthy(d,"Mouseout fired for Nevada");r.assertEq(d.selected,false,"Selected state returned correctly");
e();$('area[state="GA"]').first().click();r.assertIsTruthy(d,"Click callback fired for Georgia");
if(d){r.assertEq(d.key,"GA","Click callback fired for Georgia, and key was correct");
r.assertEq(d.selected,true,"Click callback fired for Georgia, and selected was correct");
r.assertEq(g,$('area[state="GA"]')[0],"Click callback fired for Georgia, and this was correct");
}e();$('area[state="OR"]').first().click();if(d){r.assertEq(d.key,"OR","Click callback fired for Oregon, and key was correct");
r.assertEq(d.selected,false,"Click callback fired for Oregon, and selected was correct");
}r.assertEq($(".mapster-tooltip").length,0,"No tooltip showing");e();$('area[state="CA"]').first().mouseover();
r.assertEq($(".mapster-tooltip").length,1,"Tooltip was shown");r.assertEq($(".mapster-tooltip").css("display"),"block","Tooltip is visible");
r.assertIsTruthy(d,"Click callback fired for LA tooltip");if(d){r.assertEq(d.key,"CA","Tooltip show callback fired for CA, and key was correct");
r.assertEq(d.selected,false,"Tooltip show callback fired for Louisiana, and selected was correct");
r.assertEq(g,$('area[state="CA"]')[0],"Tooltip show callback fired for Lousisiana, and this was correct");
}var p=new f(function(){r.assertEq($(".mapster-tooltip").length,0,"No tooltip showing after mouseout");
q.mapster("tooltip","CA");r.assertEq($(".mapster-tooltip").length,1,"Tooltip appeared when activated manually");
q.mapster("tooltip");r.assertEq($(".mapster-tooltip").length,0,"Tooltip hidden after manual activation");
$('area[state="CA"]').first().mapster("tooltip");r.assertEq($(".mapster-tooltip").length,1,"Tooltip appeared when activated manually calling mapster on an area");
var s=$(".mapster-tooltip").position();if($.browser.chrome){r.assertPropsEq(s,{left:50,top:199},"Tooltip for CA when no area was specified used first area");
}q.mapster("tooltip");q.mapster("tooltip",$("area[state='CA']").eq(1));r.assertEq($(".mapster-tooltip").length,1,"Tooltip appeared when activated manually with specific area");
var t=$(".mapster-tooltip").position();if($.browser.chrome){r.assertPropsEq(t,{left:38,top:178},"Tooltip for CA when 2nd area was specified was different");
}r.assertPropsNotEq(s,t,"Tooltip locations should be different when called with and without an area.");
q.mapster("tooltip","VT");r.assertEq($(".mapster-tooltip").length,1,"Nothing happened when calling tooltip on an area with no tooltips");
q.mapster("tooltip",false);r.assertEq($(".mapster-tooltip").length,0,"Tooltip closed appeared when deactivated manually");
q.mapster("unbind");j.addTest("Mapster Command Queue Tests",function(A){var x,u,y,w=$("#test_elements *").length;
function v(){var C="Master Command Queue (async completion)";var B=$(this);j.addTest(C,function(E){var D;
E.assertCsvElementsEq(B.mapster("get"),y,"Only initial selections present when simulating non-ready image");
D=$("#test_elements *").length;E.assertNotEq(D,w,"Dom size is unequal before unbinding at test end");
B.mapster("unbind");D=$("#test_elements *").length;E.assertEq(D,w,"Dom size is equal at test end");
});}u=false;x=$("#usa_image");x.mapster("test",'if (typeof u!=="undefined") {u.old=u.isImageLoaded;u.isImageLoaded=function(){return false;};}');
y="AK,TX";var z=$.extend({},i,{onConfigured:v});x.mapster(z);x.mapster("set",true,"KS,KY");
y="AK,KY,TX,KS";A.assertEq(x.mapster("get"),"","(ok to fail if obfuscated) No options present when simulating non-ready image");
x.mapster("test",'if (typeof u !== "undefined") {u.isImageLoaded=u.old;}');});});
q.mapster("set_options",{onMouseout:function(){window.setTimeout(function(){p.callback();
},100);}});$('area[state="CA"]').first().mouseout();});return j;};